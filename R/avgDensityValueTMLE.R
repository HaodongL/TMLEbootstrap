library(R6)

#' onestep TMLE of average density parameter
#'
#' @docType class
#' @importFrom R6 R6Class
#' @export
#' @keywords data
#' @return Object of \code{\link{R6Class}} with methods
#' @format \code{\link{R6Class}} object.
#' @examples
#' # avgDensityTMLE$new()
#' @field x random sample from distribution
#' @field p_hat (\code{empiricalDensity}) containing density estimates
#' @field Psi paramter value
#' @field EIC vector of EIC
#' @field epsilon_step step size for one-step targeting
#' @field CI (numeric vector) length 2; lower + upper CI
#' @field longDataOut (\code{longiData}) for transforming x into longitudinal format dataframe
#' @field HAL_tuned (\code{hal9001}) generated by \code{cv_densityHAL} class.
#' @section Methods:
#' \describe{
#'   \item{\code{new(x, epsilon_step = NULL, verbose = NULL)}}{specify data; define targeting step size}
#'   \item{\code{fit_density(bin_width = .1, lambda_grid)}}{use `cv_densityHAL` to fit density. bin_width for pre-binning of continuous x; lambda_grid for grid search of lambda in HAL}
#' }
avgDensityTMLE <- R6Class("avgDensityTMLE",
  public = list(
    x = NULL,
    p_hat = NULL,
    Psi = NULL,
    EIC = NULL,
    epsilon_step = 1e-3,
    tol = NULL,
    CI = NULL,
    verbose = FALSE,
    max_iter = 1e2,
    longDataOut = NULL,
    HAL_tuned = NULL,
    initialize = function(x, epsilon_step = NULL, verbose = NULL) {
      self$x <- x
      self$tol <- 1/length(x)
      if (!is.null(epsilon_step)) self$epsilon_step <- epsilon_step
      if (!is.null(verbose)) self$verbose <- verbose
    },
    fit_density = function(bin_width = .1, lambda_grid = c(1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 1e-1)) {
      library(SuperLearner)
      library(hal9001)
      self$longDataOut <- longiData$new(x = self$x, bin_width = bin_width)
      # longDFOut <- self$longDataOut$generate_df()
      longDFOut <- self$longDataOut$generate_df_compress()

      verbose <- FALSE
      # tune HAL for density
      cvHAL_fit <- cv_densityHAL$new(x = self$x, longiData = self$longDataOut)
      cvHAL_fit$assign_fold(n_fold = 3)
      cvHAL_fit$cv_lambda_grid(lambda_grid = lambda_grid)
      # cvHAL_fit$cv_lambda_grid(lambda_grid = NULL) # auto lambda
      hal_out <- cvHAL_fit$compute_best_model()
      HAL_tuned <- hal_out$hal_fit
      yhat <- hal_out$predict(new_x = self$longDataOut$x)

      density_intial <- empiricalDensity$new(p_density = yhat, x = self$x)
      self$p_hat <- density_intial$normalize()

      self$HAL_tuned <- HAL_tuned
      # self$HAL_tuned <- hal9001::squash_hal_fit(HAL_tuned)
    },
    calc_Psi = function(){
      # compute Psi; use x, p_hat
      # self$Psi <- mean(self$p_hat$p_density)

      dummy_df <- data.frame(id = 1:length(self$x), x = self$x, p_density = self$p_hat$p_density)
      dummy_df <- dummy_df[order(dummy_df$x),]
      dx <- c(0,diff(dummy_df$x))
      self$Psi <- sum(dummy_df$p_density^2 * dx)
    },
    calc_EIC = function() {
      # calc EIC
      self$EIC <- 2 * (self$p_hat$p_density - self$Psi)
    },
    updateOnce = function() {
      # one iteration in onestep tmle
      if (mean(self$EIC) < 0) self$epsilon_step <- -self$epsilon_step
      self$p_hat$p_density <- self$p_hat$p_density * exp(self$epsilon_step * self$EIC)
      self$p_hat$normalize()
    },
    onestepTarget = function(verbose = FALSE) {
      # recursive targeting of onestep
      n_iter <- 0
      meanEIC_prev <- abs(mean(self$EIC))
      while(abs(mean(self$EIC)) >= self$tol){
      # while(abs(mean(self$EIC)) >= 1e-20){
      # while(TRUE){
        meanEIC_prev <- abs(mean(self$EIC))
        self$calc_Psi()
        self$calc_EIC()
        # self$p_hat$display()
        self$updateOnce()
        if (self$verbose | verbose) print(c(mean(self$EIC), self$Psi))
        n_iter <- n_iter + 1
        if (abs(mean(self$EIC)) > meanEIC_prev){
          self$epsilon_step <- -self$epsilon_step
          # message('not stable!')
        }
        if (n_iter >= self$max_iter){
          break()
          message('max iteration number reached!')
        }
      }
    },
    inference = function(){
      # generate CI using EIC
      sd_EIC <- sd(self$EIC)
      upper <- self$Psi + 1.96/sqrt(length(self$EIC))*sd_EIC
      lower <- self$Psi - 1.96/sqrt(length(self$EIC))*sd_EIC
      self$CI <- c(lower, upper)
    }
  )
)